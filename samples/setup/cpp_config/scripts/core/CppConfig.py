
import os
import json
import re

class CppConfig:
	def __init__(self, str_projectDir, str_configDir):
		self.str_projectDir = str_projectDir
		self.str_configDir = str_configDir
		#
		self.str_licence = str_readFile(os.path.join(
			str_configDir,
			"licence_message.txt"
		))
		self.str_uniqueToken = str_readFile(os.path.join(
			str_configDir,
			"unique_token.txt"
		)).split()[0]
		#
		self.str_startToken = "\n" + "//AUTOGENERATED_TEXT_" + self.str_uniqueToken + "_START"
		self.str_endToken = "//AUTOGENERATED_TEXT_" + self.str_uniqueToken + "_END\n"
		#
		self.map_folderNS = {}
		lst_lst_folderNS = json.loads(str_readFile(os.path.join(
			str_configDir,
			"folder_namespaces.json"
		)))
		for str_subfolder in lst_recursiveDirs(str_projectDir):
			self.map_folderNS[str_subfolder] = ["", ""]
		for lst_folderNS in lst_lst_folderNS:
			str_namespace = lst_folderNS[1]
			str_folder = str_projectPath(
				lst_folderNS[0], 
				str_projectDir
			)
			for str_subfolder in lst_recursiveDirs(str_folder):
				lst_folderNS = self.map_folderNS[str_subfolder]
				lst_folderNS[0] += "namespace " + str_namespace + "{\n"
				lst_folderNS[1] += "}\n"
	
	#

	def applyAll(self):
		for str_path in lst_recursiveFiles(self.str_projectDir):
			self.applyFile(str_path)
	def stripAll(self):
		for str_path in lst_recursiveFiles(self.str_projectDir):
			self.stripFile(str_path)

	def applyFile(self, str_path):
		if(self._b_header(str_path) or self._b_src(str_path)):
			str_old = str_readFile(str_path)
			str_new = self._str_apply(str_old, str_path)
			if(str_new != str_old):
				writeFile_str(str_path, str_new)
				print('cpp_config changes applied to: ' + str_path)

	def stripFile(self, str_path):
		if(self._b_header(str_path) or self._b_src(str_path)):
			str_old = str_readFile(str_path)
			str_new = self._str_strip(str_old)
			if(str_new != str_old):
				writeFile_str(str_path, str_new)
				print('cpp_config stripped: ' + str_path)

	#

	def _str_apply(self, string, str_path):
		if self._b_header(str_path):
			string = self._str_applyNamespace(self._str_strip(string), str_path)
			str_macro = self._str_macro(str_path)
			return(str(
				str(
					self.str_startToken + "\n" +
					"#ifndef " + str_macro + "\n" +
					"#define " + str_macro + "\n" +
					self.str_endToken
				) +
				string +
				str(
						self.str_startToken + "\n" +
						self.map_folderNS[os.path.dirname(str_path)][1] + 
						"#endif\n" +
						"/*" + self.str_licence + "*/" + "\n" +
						self.str_endToken
				)
			))
		elif self._b_src(str_path):
			string = self._str_applyNamespace(self._str_strip(string), str_path)
			return(str(
				string +
				str(
						self.str_startToken + "\n" +
						self.map_folderNS[os.path.dirname(str_path)][1] + 
						"/*" + self.str_licence + "*/" + "\n" +
						self.str_endToken
				)
			))
		else:
			return(string)

	#returns string of autogenerated text
	def _str_strip(self, string):
		return(re.sub(
			str(
				"\n?" + self.str_startToken[1:] + 
				".*?" + 
				self.str_endToken[:-1] + "\n?"
			),
			"", 
			string,
			flags=re.S
		))

	#returns the string with the autogenerated namespace applied to it.
	def _str_applyNamespace(self, string, str_path):
		str_folder = os.path.dirname(str_path)
		if(str_folder in self.map_folderNS):
			match = re.compile(
				str(
					"(" + ".*" + "#include" + ".*?" + "\n" + ")" + 
					"(.*)"
				),
				flags=re.S
			).match(string)
			if(match == None):
				return(str(
					str(
						self.str_startToken + "\n" +
						self.map_folderNS[str_folder][0] + 
						self.str_endToken
					) +
					string
				))
			else:
				return(str(
					match.group(1) +
					str(
						self.str_startToken + "\n" +
						self.map_folderNS[str_folder][0] + 
						self.str_endToken
					) +
					match.group(2)
				))
		else:
			return(string)

	#

	def _str_macro(self, str_path):
		str_localPath = os.path.relpath(str_path, self.str_projectDir)
		return(str(
			"INCLUDE_GAURD_" +
			self.str_uniqueToken + "_" +
			str_localPath.upper().replace(os.sep, "_").replace(".", "_")
		))

	def _b_header(self, str_path):
		return(
			str_path.endswith(".h") or
			str_path.endswith(".hpp")
		)
	def _b_src(self, str_path):
		return(
			str_path.endswith(".c") or
			str_path.endswith(".cpp") or
			str_path.endswith(".cxx")
		)

#

def joinPaths(lst_paths):
	if(len(lst_paths) == 0):
		return root_path()
	else:
		result = lst_paths[0]
		for str_path in lst_paths[1:]:
			os.path.join(result, str_path)
		return result

#raw path should use '/' seperators
#path must not have '/' as folder or file names.
#returns an absolute path.  if rawPath is local, it'll be relative to projectDir
def str_projectPath(str_rawPath, str_projectDir):
	lst_path = str_rawPath.split("/")
	str_path = joinPaths(lst_path)
	if(not os.path.isabs(str_path)):
		str_rawPath = os.path.join(str_projectDir, str_rawPath)
	return str_rawPath

def lst_recursiveDirs(str_dir):
	lst = []
	for dirname, subdirs, subfiles in os.walk(str_dir):
		lst.append(dirname)
	return lst

def lst_recursiveFiles(str_dir):
	lst = []
	for dirname, subdirs, subfiles in os.walk(str_dir):
		for subfile in subfiles:
			lst.append(os.path.join(dirname, subfile))
	return lst

def str_readFile(str_filename):
	file = open(str_filename, 'r')
	s = file.read()
	file.close()
	return s

#write string to file
def writeFile_str(str_filename, string):
	file = open(str_filename, 'w')
	file.write(string)
	file.close()



